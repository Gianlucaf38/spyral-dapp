# ðŸŽµ Spyral â€“ Song Asset dApp

## 1. Project Overview

**Spyral** is a modular blockchain-based decentralized application (dApp) designed to manage the lifecycle of a musical asset represented as an NFT.

Each song is minted as a dynamic on-chain asset and progresses through a structured lifecycle:

1. Upload  
2. Collaborate  
3. Register  
4. Publish  
5. Revenue Distribution  

The system integrates:

- Smart contracts deployed on **Base Sepolia**
- **Chainlink Functions** for off-chain data verification (Spotify & streaming data)
- **IPFS** for decentralized metadata storage
- An external **FastAPI server** to dynamically generate NFT metadata
- A frontend interface for interaction
- OpenSea compatibility for marketplace visibility

The project demonstrates how blockchain can be used to:

- Coordinate multiple collaborators  
- Verify external publishing status  
- Track streaming thresholds  
- Enable transparent revenue splitting  

---

## 2. Technology Stack

| Technology | Description |
|------------|-------------|
| Solidity | Smart contract language used to implement SongAsset and modular logic |
| Hardhat | Development framework for compiling, testing, and deploying contracts |
| Base Sepolia | Ethereum-compatible testnet where contracts are deployed |
| Chainlink Functions | Used as decentralized oracle to fetch Spotify publication and stream data |
| IPFS | Decentralized storage for NFT metadata JSON |
| FastAPI | Python backend used to dynamically build and serve NFT metadata |
| Python | Backend logic for API server and Web3 interaction |
| Docker | Containerization of the API server |
| Railway | Deployment platform for hosting the API server |
| OpenSea | NFT marketplace used to visualize the minted Song Assets |
| Wagmi / RainbowKit | Web3 frontend interaction and wallet connection |

---

## 3. Repository Structure

```
spyral-dapp/
â”‚
â”œâ”€â”€ contracts/
â”‚   â”œâ”€â”€ SongStorage.sol
â”‚   â”œâ”€â”€ SongLifecycleManagement.sol
â”‚   â”œâ”€â”€ SongOracleModule.sol
â”‚   â”œâ”€â”€ SongRoyaltiesModule.sol
â”‚   â””â”€â”€ SongAsset.sol
â”‚
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ deploy.js
â”‚
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ SongAsset.test.js
â”‚   â””â”€â”€ SongAssetOracleMock.test.js
â”‚
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ Dockerfile
â”‚
â”œâ”€â”€ frontend/
â”‚   â””â”€â”€ (React / Next.js application)
â”‚
â””â”€â”€ hardhat.config.js
```

---

## 4. Smart Contract Architecture & Main Functions

The architecture follows a **modular inheritance design**.

### 4.1 SongStorage.sol

Responsible for persistent storage structures.

Contains:

- Song struct definition  
- Mapping `tokenId â†’ Song`  
- Mapping for collaborators  
- Stream count  
- Spotify ID  
- Revenue balances  

This contract contains no business logic, only state variables.

---

### 4.2 SongLifecycleManagement.sol

Implements the finite state machine of a song.

Main responsibilities:

- Define lifecycle states (Upload â†’ Collaborate â†’ Register â†’ Publish â†’ Revenue)  
- `advanceState(uint256 tokenId)`  
- Validate allowed transitions  
- Enforce role permissions  

This ensures controlled progression of the asset.

---

### 4.3 SongOracleModule.sol

Handles interaction with Chainlink Functions.

Main responsibilities:

- Send request to Chainlink Router  
- Store pending request context  
- Handle `fulfillRequest(...)`  
- Update:
  - Spotify publication status  
  - Stream count  

This module bridges on-chain logic with off-chain data.

---

### 4.4 SongRoyaltiesModule.sol

Manages revenue splitting and withdrawals.

Main responsibilities:

- Store collaborator percentages  
- Allow revenue deposit  
- Split revenue proportionally  
- Allow collaborators to withdraw  

Implements trustless revenue sharing logic.

---

### 4.5 SongAsset.sol

Final contract inheriting all modules.

Responsibilities:

- ERC721 implementation  
- `mintSong(address to, bytes32 audioHash)`  
- Integrates storage, lifecycle, oracle, and royalties logic  

This is the main deployed contract.

---

## 5. Storage Model (On-Chain vs IPFS)

### On-Chain (Base Sepolia)

Stored directly inside smart contract storage:

- Song lifecycle state  
- Collaborators and percentages  
- Spotify ID  
- Stream count  
- Revenue balances  
- Audio hash reference  
- Token ownership (ERC721)  

Why on-chain?

- Trustless state management  
- Deterministic lifecycle enforcement  
- Transparent royalty logic  

---

### IPFS

Stored off-chain:

- NFT Metadata JSON  
- Image references (if any)  

Metadata is dynamically generated by the external API and can include:

- Current lifecycle state  
- Stream milestone  
- Publication status  

IPFS ensures:

- Decentralized storage  
- Marketplace compatibility  
- Immutable metadata references  

---

## 6. External API Server Architecture

The API server is implemented using:

- Python  
- FastAPI  
- Web3.py  
- Docker  
- Railway  

### GET Flow: `/spyral/metadata/{tokenId}`

1. Receive GET request  
2. Validate token existence  
3. Query smart contract via Web3:
   - `getSongData(tokenId)`  
   - `getCollaborators(tokenId)`  
4. Unpack on-chain data  
5. Dynamically build JSON metadata  
6. Return formatted JSON (HTTP 200)  

If token not found â†’ return 404.

This enables:

- Dynamic NFT metadata  
- Marketplace refresh  
- Off-chain JSON formatting with on-chain data integrity  

---

## 7. Lifecycle Flow Summary

### Upload

- Artist calls `mintSong`  
- Initial state: Upload  

### Collaborate

- Add collaborators  
- Define revenue splits  
- Advance state  

### Register

- Set Spotify ID  
- Chainlink verifies publication  

### Publish

- Chainlink retrieves stream count  
- If threshold met â†’ asset becomes monetizable  

### Revenue

- Users deposit funds  
- Owner splits revenue  
- Collaborators withdraw  

---

## 8. Oracle Flow (Chainlink)

1. Smart contract sends request to Chainlink Router  
2. Router forwards to DON  
3. Off-chain JavaScript fetches Spotify data  
4. DON returns response  
5. `fulfillRequest()` updates contract state  

This follows a **pull-based oracle pattern** triggered by contract logic.

---

## 9. Why Blockchain Here?

Compared to a traditional client-server architecture:

- State transitions are immutable  
- Revenue splits are trustless  
- Collaborator permissions are enforced on-chain  
- Oracle responses are verifiable  
- No central authority controls payout logic  

---

## 10. Potential Improvements

- Event indexing strategy for frontend efficiency  
- Upgradeability pattern (Proxy pattern not implemented)  
- Gas optimization review  
- More granular access control (Ownable vs Role-based)  
- Automated metadata pinning strategy  
- Better error handling for oracle failures  
- Production deployment documentation  
- CI/CD pipeline documentation  

---

## 11. Conclusion

Spyral demonstrates a full-stack Web3 architecture integrating:

- Modular Solidity contracts  
- Chainlink oracle logic  
- Dynamic NFT metadata  
- Off-chain API orchestration  
- Decentralized storage  
- Trustless revenue distribution  

It is designed as an academic yet production-structured example of how blockchain can coordinate digital music assets in a decentralized way.
